###第九天：

####第九天草稿：

购物车

问题：
在购物车处理之前，用户必须登录
如果用户没有登录，必须用户请求就跳转到登录的页面
触发点，在在转向购物车时，判断，如果没有登录就转向登录页面，
多个地方要触发登录。修改商品数量、删除商品等，必然引发转向登录页面。

利用 AOP 思想切面编程来实现
使用拦截器，购物车


MQ
messageQueue
消息队列

常用：
Apache ActiveMQ
ZeroMQ 大数据常用（速度最快，c语言写的）
RabbitMQ 与spring无缝整合

消息队列目的：
JMS 消息传递，异步，消息队列

[图片]
P product 消息的产生者
C customor 消息的消费者
消费完消息，消息被从队列中删除
erlang 语言，并发
[图片]

[图片]

[图片]
基于 AMQP

安装完 rabbitMQ
创建用户
创建 vh
绑定权限

1.基础模式
一个发，一个收
2.Work queues 工作模式
一个发，多个消费者消费，谁抢到谁消费
3.Publish/Subscribe 发布订阅
发送使用exchange，多消息队列，每个队列绑定一个消费者
4.Routing 路由模式
根据队列规则，分配给不同的队列，比较时根据队列顺序路由
5.Topic 主题模式
模糊匹配
根据匹配规则进行全部分配
[图片]

[图片]




####第九天总结：
知识回顾：
1）购物车，直接调用接口
当用户选中商品，添加到购物车中时，
判断，如果此商品已经在购物车中，数量进行增加，
如果商品不在购物车中，直接进行添加。
修改商品数量，用户在购物车中点击 + 或 - 号，分两个动作，
js 将页面的此商品的数量进行增减，
将此商品的数量值直接发送 get 方式提交，将数量和商品的 ID 通过，
采用 RESTFul 形式将它提交到后台。还需要 userId 参数，从TheadLocal中获取到 user,
从 user 中获取到 userId，然后通过这 3 个参数直接修改数据库。

访问购物车时，怎样保证系统已经登录了？
应用 AOP 面向切面编程，只要访问路径中以 /cart 开头的都进行拦截，
拦截后去 cookie 中获取 ticket，通过 ticket，去 SSO 单点登录的查询接口，
最终从 redis 中获取当前 user 的 json 串。
获取到就返回 user 信息，反之如果 user 为 null，转向登录页面。

hibernate，处理 user 对象，把持久化的对象放入到 httpSession 中，
对象关联，默认懒加载；
mybatis，处理 user 对象，把持久化的对象放入到 httpSession 中，
单个对象或这立即加载的对象集合。效率高
SSO 机制，多个子系统之间互相调用。系统之间可能不在一个虚拟机中，序列化。
通用解决方案，轻量级 json (ajax+RESTFul+json)

2）MQ 消息队列
和 httpClient 比较

httpClient 基于 HTTP 协议，工具类（死的），同步，直接就在一点上使用
需要上下文，request对象，将参数封装到request中，最终还需要通关response来响应
紧耦合。

MQ rabbitMQ 基于 AMQP 协议，MQ 容器（活的），异步（容纳更多的内容），
在两个点上使用，消息生产者 P、消息的消费者 C，
P 产生完消息，就不关心消息是否被消费掉，
C 只关心消息的队列中是否有消息存在，有消息存在就判断是否是我的消息，
是我的就消费，消费完删除，如果不是，继续监听。
松耦合。

混合技术应用。httpClient+RabbitMQ+redis+json+ajax


